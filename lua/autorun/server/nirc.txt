-- Nebual 2013 (nebual@nebtown.info)
-- NIRC - Nebcorp IRC Integration Module
NIRC = NIRC or {}

-- [CONFIG]
NIRC.ip = "192.168.0.162"
NIRC.port = 6667 -- 6667 is default
NIRC.channel = "#nebtown" -- Default channel (lowercase)
NIRC.timeout = 25 -- If clients keep getting dropped by the IRC server try lowering this
NIRC.botname = "Gman" -- Name of the bot which listens for messages
NIRC.prefix  = "[GM]" -- Prefix for Gmod users nicknames in IRC
NIRC.connectingprefix = "[---]" -- Prefix for Gmod players nicknames when initially connecting
-- [END CONFIG]

local nirc_module = CreateConVar("nirc_module", "glsock2", {FCVAR_ARCHIVE}, "Socket Module to use. {glsock2, litesocket}")
local nirc_debug = CreateConVar("nirc_debug", 0)

if not NIRC.socks then
	-- Reloading the script will not reload this section
	concommand.Add("nirc_reload", function() include("autorun/server/nirc.lua") end)
	concommand.Add("nirc_refresh", function()
		NIRC.Shutdown()
		timer.Create("NIRC_Refresh", 2, 1, function() NIRC = nil include("autorun/server/nirc.lua") end)
	end)
	AddCSLuaFile("autorun/client/cl_nirc.lua")
	
	-- Define these here so that connections persist
	NIRC.logcache = ""
	NIRC.socks = {}

	timer.Simple(0.4, function()
		NIRC.Connect(NIRC.botname)
		if CurTime() > 10 then
			for _,v in ipairs(player.GetAll()) do NIRC.Connect(v:Nick()) end 
		end
	end)
	util.AddNetworkString(NIRC.botname)
	util.AddNetworkString("nirc_say")
	util.AddNetworkString("nirc_usrmsg")
	util.AddNetworkString("nirc_sysmsg")
end

if nirc_module:GetString() == "glsock2" then
	if not GLSock then require("glsock2") end
	
	local function nullfunc() return end
	function NIRC.Send(nick, msg)
		local buffer = GLSockBuffer()
		buffer:Write(msg.."\r\n")
		NIRC.socks[nick]:Send(buffer, nullfunc)
	end
	
	local recv = ""
	local function ReadLine(sock, buffer, err)
		if err == GLSOCK_ERROR_SUCCESS then
			local count, data = buffer:Read(buffer:Size())
			recv = recv .. data
			while true do
				local eol = string.find(recv, "\r\n", 1, true)
				if not eol then break end
				local data = recv:sub(1, eol)
				
				if nirc_debug:GetBool() then print("NIRC: "..data) end
				NIRC.HearIRC(data)
				
				recv = recv:sub(eol+2, -1)
			end
			sock:Read(8192, ReadLine)
		else
			print("NIRC ReadError: "..err)
			sock:Close()
		end
	end
	local function ReadLineDebug(sock, buffer, err)
		if err == GLSOCK_ERROR_SUCCESS then
			local count, data = buffer:Read(buffer:Size())
			recv = recv .. data
			while true do
				local eol = string.find(recv, "\r\n", 1, true)
				if not eol then break end
				local data = recv:sub(1, eol)
				
				if nirc_debug:GetBool() then print("NIRCd: "..data) end
				if data:sub(0,20) == "ERROR :Closing Link:" then
					for nick, v in pairs(NIRC.socks) do
						if v == sock then
							for _,v in pairs(player.GetAll()) do
								if string.find(string.lower(v:Nick()), string.lower(name)) then 
									print("NIRC: "..nick.."'s socket closed, reconnecting!")
									NIRC.Connect(nick)
								end
							end
							print("NIRC: "..nick.."'s socket closed, goodbye.")
							return 
						end
					end
				end
				
				recv = recv:sub(eol+2, -1)
			end
			sock:Read(8192, ReadLineDebug)
		else
			print("NIRCd ReadError: "..err)
			sock:Close()
		end
	end
	
	function NIRC.NewConnection(initnick, nick, prefixnick)
		local connection = GLSock(GLSOCK_TYPE_TCP)
		NIRC.socks[initnick] = connection
		
		connection:Connect(NIRC.ip, NIRC.port, function(sock, err)
			if err == GLSOCK_ERROR_SUCCESS then
				-- The connection succeeded, lets tell the server that we're an IRC client, and our nickname
				NIRC.Send(initnick, "USER GM-"..nick.." 0 0 :NIRC User")
				if prefixnick then NIRC.Send(initnick, "NICK "..NIRC.connectingprefix..nick) else NIRC.Send(initnick, "NICK "..NIRC.prefix..nick) end
				
				local function ConnectReadLine(sock, buffer, err)
					if err == GLSOCK_ERROR_SUCCESS then
						local count, data = buffer:Read(buffer:Size())
						if nirc_debug:GetBool() then print("NIRC Connect: "..data) end
						
						-- The server will respond with "PING :secretcode", which we must send back to it
						local ping = string.find(data, "PING :",0,true)
						if ping then
							NIRC.Send(initnick, "PONG "..string.sub(data, ping+6, ping+15))
							NIRC.Send(initnick, "JOIN "..NIRC.channel)
							
							-- Only the main bot needs to listen from now on
							if initnick == NIRC.botname then 
								sock:Read(8192, ReadLine)
								if CurTime() < 10 then 
									NIRC.Say("Server loaded on "..game.GetMap().."!")
								else
									NIRC.Say("... Sorry about my absence!") 
								end
							else
								sock:Read(8192, ReadLineDebug)
							end
						else
							sock:ReadUntil("\r\n", ConnectReadLine)
						end
					else
						print("NIRC ReadError: "..err)
						sock:Close()
					end
				end
				sock:ReadUntil("\r\n", ConnectReadLine)
			else
				print("NIRC ConnectError: "..err)
			end
		end)
	end
	
	function NIRC.Shutdown()
		for k,v in pairs(NIRC.socks) do NIRC.Disconnect(k) end
	end

elseif nirc_module:GetString() == "litesocket" then
	if not Socket then require("litesocket") end
	function NIRC.Send(nick, msg)
		NIRC.socks[nick]:Send(msg.."\r\n")
	end
	
	function NIRC.NewConnection(initnick, nick, prefixnick)
		local connection = Socket(IPPROTO_TCP)
		NIRC.socks[initnick] = connection
		
		if nick == NIRC.botname then
			-- The main bot needs a callback so he can tell the server about IRC chat, nobody else does
			timer.Create("NIRC.CheckRecvStart",4,1,function()
				if GetConVarNumber("NIRC_Debug") == 0 then local data,err = connection:Recv(8192*8) end// Throw all this initial shit out, there might be history commands (like 'gman map gm_construct') that'd cause restart loops
				timer.Create("NIRC.CheckRecv",0.25,0,function() 
					local data,err = connection:Recv()
					if !err then
						for _,line in pairs(string.Explode("\r\n",string.sub(data,1,-2))) do
							if GetConVarNumber("NIRC_Debug") != 0 then print("NIRC: "..line) end
							NIRC.HearIRC(line)
						end
					elseif err == "socket is closed" then
						timer.Remove("NIRC.CheckRecv")
						NIRC.Connect(nick)
					elseif err ~= "timeout" then -- This just means the Recv() function timed out (no data)
						ErrorNoHalt("NIRCError ("..err.."): "..tostring(data))
					end
				end)
			end)
			connection:Connect(NIRC.ip, NIRC.port);
			connection:Send("USER GM-"..NIRC.botname.." 0 0 :Lord of Carrot Flowers\r\n")
		else
			connection:Connect(NIRC.ip, NIRC.port);
			connection:Send("USER GM-"..nick.." 0 0 :NIRC User\r\n")
		end
		if prefixnick then connection:Send("NICK "..NIRC.connectingprefix..nick.."\r\n") else connection:Send("NICK "..NIRC.prefix..nick.."\r\n") end
		timer.Create("NIRC_JoinChan_"..nick,1.25,1,function()
			recv = connection:Recv()
			if !recv then
				print("NIRC: Failed to connect "..nick..", retrying...")
				timer.Create("NIRC_Retry_Connect_"..nick, 2, 1, function() NIRC.Connect(nick) end)
				if not timer.Exists("NIRC_connection_failed_"..nick) then timer.Create("NIRC_connection_failed_"..nick, 10, 1, function()
					timer.Remove("NIRC_Retry_Connect_"..nick)
					ErrorNoHalt("NIRC: Failed to connect "..nick.." after 4 attempts!")
				end) end
			else		
				timer.Remove("NIRC_connection_failed_"..nick)
				local pongcode = string.sub(recv,string.find(recv, "PING :",0,true)+6, string.find(recv, "PING :",0,true)+15)
				connection:Send("PONG "..pongcode.."\r\n")
				connection:Send("JOIN "..NIRC.channel.."\r\n")
 				if nick == botname then
					if CurTime() < 10 then 
						NIRC.Say("Server loaded on "..game.GetMap().."!")
					else
						NIRC.Say("... Sorry about my absence!") 
					end
				end
			end
		end)
	end
	
	function NIRC.Shutdown()
		for k,v in pairs(NIRC.socks) do NIRC.Disconnect(k) end
		timer.Destroy("NIRC.CheckRecvStart")
		timer.Destroy("NIRC.CheckRecv")
	end
end

NIRC.DefaultNicks = {"Friedrich","Wilhelm","Cornelius","ARGON_527","Wacklers","Whoppers","Watson","Walter","Waddington","Alfredo","Mikhail"}
NIRC.TempNames = {} 
function NIRC.Connect(initnick, prefixnick)
	-- Disconnect him first, just in case
	NIRC.Disconnect(initnick)
	
	-- Purify the name of spaces and weird characters, underscores are k
	local nick = string.sub(string.gsub(string.gsub(initnick, " ", "_"), "[^%w_]", ""), 1, 15)
	if !nick || nick == "" then nick = table.Random(NIRC.DefaultNicks) NIRC.Say("The name "..initnick.." is too ridiculous for IRC, renaming him "..nick.."!") end
	local port = tonumber(GetConVarString( "hostport" ))
	if nick == NIRC.botname and port != 27015 then
		// For Nebgate
		nick = nick .. (port-27014)
	end
	NIRC.TempNames[initnick] = nick
	
	NIRC.NewConnection(initnick, nick, prefixnick)
end

hook.Add("ShutDown", "NIRC.Shutdown", NIRC.Shutdown)

hook.Add("PlayerConnect", "NIRCAnnouncePlayerConnect", function(name)
	if string.Left(name, 3) == "Bot" || name == string.char(1) then return true end // Don't let bots or the SETTI server checker join
	NIRC.Connect(name, true)
	timer.Create("NIRC.DisconnectFailedConnects_"..name, 600, 1, function()
		-- After 10 minutes, check if the player exists, disconnect him otherwise
		for _,v in pairs(player.GetAll()) do
			if string.find(string.lower(v:Nick()), string.lower(name)) then return end
		end
		NIRC.Disconnect(name)
	end)
end)

hook.Add( "PlayerInitialSpawn", "NIRC_PlayerInit", function(ply) 
	if string.Left(ply:Nick(), 3) == "Bot" then return end
	ply.OldName = ply:Nick()
	if NIRC.socks[ply:Nick()] then
		timer.Create(ply:Nick().."NIRC_delay", 2, 10, function()
			if !IsValid(ply) || string.Left(ply:Nick(), 3) == "Bot" then return end
			if !NIRC.TempNames[ply:Nick()] then NIRC.TempNames[ply:Nick()] = string.sub(string.gsub(string.gsub(ply:Nick(), " ", "_"), "[^%w_]", ""), 1, 15) end
			if NIRC.socks[ply:Nick()] then NIRC.Send(ply:Nick(), "NICK "..NIRC.prefix..NIRC.TempNames[ply:Nick()]) end
		end)
	else
		NIRC.Connect(ply:Nick())
	end
end)

function NIRC.Disconnect(nick)
	if nirc_debug:GetBool() then print("NIRC: Disconnecting player "..nick) end
	for _,v in pairs(player.GetAll()) do
		if v.OldName && NIRC.socks[v.OldName] && v:Nick() != v.OldName && v:Nick() == nick then 
			NIRC.Send(v.OldName, "QUIT")
			NIRC.socks[v.OldName] = nil 
			v.OldName = nick 
			break 
		end
	end
	if NIRC.socks[nick] then NIRC.Send(nick, "QUIT") end
	NIRC.socks[nick] = nil
end
-- It uses EntityRemoved because PlayerDisconnected doesn't catch all disconnects.
hook.Add("EntityRemoved","NIRC.Disconnect",function(ent)
	if ent:IsValid() and ent.Nick then
		NIRC.Disconnect(ent:Nick())
	end
end)

hook.Add("PlayerInitialSpawn","NIRC.AnnounceInitialSpawn",function(ply)
	if string.Left(ply:Nick(), 3) == "Bot" then return end
	net.Start("nirc_say")
		net.WriteString(NIRC.botname)
		net.WriteString(ply:Nick().." has finished loading.")
	net.Broadcast()
end)

timer.Create("NIRC_Pong",NIRC.timeout,0,function()
	for nick, v in pairs(NIRC.socks) do NIRC.Send(nick, "PONG 5") end
end)

function NIRC.HearIRC(line)
	local lines = string.Explode(" ", line)
	local nick,cmd,channel,msg = string.sub(lines[1], 2, (string.find(lines[1], "!") or 0) - 1), lines[2], lines[3], ""
	if string.Left(nick, 4) == NIRC.prefix or string.Left(nick,4) == "[MC]" or string.Left(nick, 3) == "[--" then return end -- Skip it if its just a Gmodder
	if string.Left(nick, 1) != "[" then nick = "[IRC]"..nick end
	if cmd == "PRIVMSG" then
		msg = lines[4] or ""
		for k=5, #lines do
			msg = msg .." ".. lines[k]
		end
		msg = string.sub(msg,2,-2)
		if string.lower(channel) == NIRC.channel then
			if string.sub(msg,2,7) == "ACTION" then
				net.Start("nirc_usrmsg")
					net.WriteString(nick)
					net.WriteString(string.sub(msg, 9))
				net.Broadcast()
			else
				net.Start("nirc_say")
					net.WriteString(nick)
					net.WriteString(msg)
				net.Broadcast()
				E2IRCLastSpoke = nick -- NTE
				E2IRCLastSaid = msg -- NTE
			end
			print(nick..": "..msg)
			NIRC.LogChat(nick, msg.."\n")
		end
		NIRC.GmanProcess(nick, msg, channel) -- NTE
		return
	elseif cmd == "JOIN" then
		msg = "has joined "..NIRC.channel.." IRC."
	elseif cmd == "QUIT" || cmd == "PART" then
		msg = "has left "..NIRC.channel.." IRC."
	elseif cmd == "NICK" then
		if string.find(nick, NIRC.connectingprefix) then return end
		msg = "has changed their name to [IRC]"..channel
	elseif tonumber(cmd) || cmd == "NOTICE" then
		return -- most of the numbered messages are really boring
	end
	NIRC.HearIRCNebtown(nick, cmd, channel, msg) -- NTE
	
	-- System Messages (quits, name changes)
	net.Start("nirc_sysmsg")
		net.WriteString(nick.." "..msg)
	net.Broadcast()
	print(nick.." "..msg)
end

hook.Add( "PlayerSay", "NIRC_HearGmod", function(ply, msg)
	if msg:sub(1,1) == "!" then return end
	NIRC.Say(ply:Nick(),msg)
	NIRC.GmanProcess(ply:Nick(), msg) -- NTE
end)

-- Chat Logs
-- We write to a temporary cache variable to reduce disk writes
local chatcache = "[SRCDS server started on "..os.date("%A %B %d, %Y")..".]\n"
function NIRC.LogChat(nick, msg)
	nick = string.sub(nick, 1, 15)
	chatcache = chatcache .. os.date("[%H:%M]")..string.rep(" ", 15 - string.len(nick))..nick..": "..msg
end
local filename = os.date("nebcorp/chats/%Y-%B/%d-%A.txt")
file.CreateDir(  os.date("nebcorp/chats/%Y-%B"))
local filecache = file.Read(filename,"DATA") or ""
timer.Create("Nebcorp_ChatLogWrite", 30, 0, function()
	if chatcache != "" then 
		filecache = filecache .. chatcache
		file.Write(filename, filecache)
		chatcache = ""
	end
end)

function NIRC.Say(nick, msg)
	if !msg then 
		msg = nick 
		nick = NIRC.botname
		net.Start("nirc_say") // Tell Gmod
			net.WriteString(NIRC.botname)
			net.WriteString(msg)
		net.Broadcast()
		print(NIRC.botname..": "..msg)
	end
	if NIRC.socks[nick] then 
		NIRC.Send(nick, "PRIVMSG "..NIRC.channel.." :"..msg)
	else
		print("NIRC: What?! "..nick.." has no socket! Making him one.")
		NIRC.Connect(nick) 
		timer.Create("NIRC.Say_Delay_"..nick,2.5,1,function() NIRC.Send(nick, "PRIVMSG "..NIRC.channel.." :"..msg) end)
	end
	NIRC.LogChat(nick, msg.."\n")
end

concommand.Add("changenick", function(ply,cmd,args)
	if !ply:IsValid() then print("Console can't change nicks you nub!") return end
	ply.Nickname = args[1]
	NIRC.Send(ply:Nick(), "NICK "..NIRC.prefix..args[1])
	NIRC.Say(ply:Nick().." has changed their name to "..args[1].."!")
end)

concommand.Add("y", function(ply,cmd,args,said)
	if string.Left(said,1) == "/" then 
		-- A command! Send it raw, without the usual "PRIVMSG #channel :" prefix
		NIRC.Send(NIRC.botname, string.sub(said, 2)) 
	else 
		NIRC.Say(said)
	end
end)

include("autorun/server/nirc_nebtown.lua") -- NTE

print("[NIRC - Nebcorp's IRC Relaying Capsule Loaded]")
